import os
import numpy as np
import sys
import re
import time

##!!python replace filename.vasp mode 0 0  ##for a single sub
##!!python replace filename.vasp mode 1 4  ##muti sub for files named filename-1.vasp to filename-4.vasp

#in this script,you don't need to copy a jobscript,what you need to do is PREPARE only TWO FILES!

##File prepare:
#1.prepare mode file and name as"in_scf" or "in_bands" and so on in current dir(you dont need to worry about the "nat" or "ntyp" or "nbnd" or "ATOMIC_SPECIES" or "CELL_PARAMETER" or "ATOMIC_POSITION",replace.py will calculate that for you)
#2.prepare the vasp file name end with ".vasp" and shall be fractional

##Functions:
#1.Auto_psp_copy:change the content in *sp_format* below for your psuedo potential, they will be copied from open/psp/
#2.Auto_atomic_layer_fixed:change the fixed atom layer by *upper_layer* and *bottom_layer*
#3.Switching flat:you can sub on different computational node only change "flat_number" below

##Others:
#1.Use run-all.py mode for sub all .vasp file in current dir
#2.Use read_relax_E.py for reading all Energies in current dir and also for a continuos calculation based on Prof.Zhengfan's bcon.sh scripts(bcon.sh shall be copy to your ~/bin/. command:cp /hpc/data/home/spst/zhengfan/open/bcon.sh ~/bin/.)
#3.Use read_qe_out_all.py for extrating all .xsf file from relax calculation in current dir base on Prof.Zhengfan's read_qeout_relax.py
#4.delelte the "delete_me_rm_file" file in dir generated by sripts if you want to start over

##SPIN and DFT+U:
#1.if use spin, the easiest way is set the spin down atom into another kind and edit the atomic species, for example, you wanna establish Ni1 and Ni2 whose spins is opposite, you can replace the Ni2 site with for example Au, and then close the vesta and open the vaspfile, reedit the Au into Ni2 and reedit the Ni into Ni1, then the program will read the diff and set the input for you.
#   And also make a new file named "SPIN" to specify the starting magnetization
#2. if use DFT+U,make a new file named "DFT-U" and settle the spin,notice the filename "SPIN" and "DFT-U" can be edit in the program


sub_script=1       #if you want to sub script on computational node,set this to 1

fixed_atom_mode=0   #turn this to 1 to fix atom and the atom fixed is set below:
upper_layer=0.14    #the upper of the fixed layer
down_layer=0.00      #the botton of the fixed layer
fixed_atom_index=[]

prefix="BTO"
spin_file="SPIN"   #the spin file
dftu_file="DFT-U"  #the DFT+U file
sp_format="X.SG15.PBE.UPF" #psp format psp_format_list=["X.SG15.LDA.UPF","X.SG15.PBE.UPF","X_frl_gga.upf","X_srl_gga.upf","ONCV.PWM.X.UPF","ONCV.PWM.X.IN"]
cnct_syb="-"           #the connected symbol of your file and the number,used in multi replace
bcon_mode=0            #when do relax and find some results not converge,open this and auto use bcon.sh
solvation_model=0     #solvation model
###################
qe_dir="/hpc/data/home/spst/zhengfan/open/replace"
JOB="xty_test"                                        #the jobscript name
qe_version="6.8"

root_dir = os.path.expandvars('$HOME')
#code_dir="%s/bin/QE-batch"%root_dir
code_dir=sys.path[0]
############job_script_settings##########
flat_info=open("%s/flat.save/FLAT_INFO"%code_dir).readlines()
for lines in flat_info:
    if lines.find("flat_number=")!=-1:
        flat_number=int(lines.split("flat_number=")[-1].split("#")[0])
    if lines.find("node_num=")!=-1:
        node_num=int(lines.split("node_num=")[-1].split("#")[0])
    if lines.find("ppn_num")!=-1:
        ppn_num_man=int(lines.split("ppn_num=")[-1].split("#")[0])
        if ppn_num_man==0:
            ppn_set=0
        elif ppn_num_man!=0:
            ppn_set=1
    if lines.find("wall_time=")!=-1:
        wall_time=lines.split("wall_time=")[-1].split("#")[0].strip("\n")


#flat_number=2           # 1 for"zf_normal",2 for "spst_pub",3 for "dm_pub_cpu"
#node_num=2
#wall_time="116:00:00"
#ppn_set=1
#ppn_num_man=16
####################"zf_normal" has 52ppn,"spst_pub" has 32 ppn ,"dm_pub_cpu" has 32 ppn
if flat_number==1:
    type_flat="zf_normal"
if flat_number==2:
    type_flat="spst_pub"
if flat_number==3:
    type_flat="dm_pub_cpu"
####################above is what you need to change####################################
split_sybol_virtual="-"

vaspfile=sys.argv[1]

mode = sys.argv[2]      #the mode of files you wanna input

error=0

if (mode!= "scf") & (mode!="surf") & (mode!="relax") & (mode!="bands") & (mode!="pdos") & (mode!="BaderCharge"):
    error=1 

molecule = vaspfile.split(".vasp")[0]            

input2 = ".vasp"

export_input_file="in_"+mode+"_"+molecule     #the name of files you wanna export

file_min=int(sys.argv[3])
file_max=int(sys.argv[4])                        #the minimun maximum number of your files

#print(type(vaspfile),type(mode),type(file_min),type(file_max))

batch_mode=0

if file_min!=0:
    if file_max!=0:
        if file_min<file_max:
            batch_mode=1
        if file_min>file_max:
            error=1
            print("please check the min and max number!")
    if file_max==0:
        error=1
        print("please check the min and max number!")

elif file_min==0&file_max==0:
    error=0
    batch_mode=0
        
#print("batchmode:%d error:%d"%(batch_mode,error))


mode_name='in_'+mode

dir_file=(os.popen("pwd").read())
dir=max(dir_file.split('\n'))

input=''

def JOB_func(type_flat,node_num):

    type_hpc=""
    if type_flat=="spst_pub":
        ppn_num=32
        type_hpc="pbs"
    elif type_flat=="zf_normal":
        ppn_num=52
        type_hpc="pbs"
    elif type_flat=="dm_pub_cpu":
        ppn_num=32
        type_hpc="sbatch"
    if ppn_set==1:
        ppn_num=ppn_num_man
    ppn_tot=node_num*ppn_num

    #print(type_flat,node_num,ppn_num,wall_time)
    if type_hpc=="pbs":
        jobscript_file_in=['#!/bin/bash\n',
        '#PBS  -N   coolxty\n',
        '#PBS  -l   nodes=%d:ppn=%d\n'%(node_num,ppn_num),
        '#PBS  -l   walltime=%s\n'%wall_time,
        '#PBS  -S   /bin/bash\n',
        '#PBS  -j   oe\n', 
        '#PBS  -q   %s\n'%(type_flat),
        '\n',
        'cd $PBS_O_WORKDIR\n',
        '\n',
        'NPROC=`wc -l < $PBS_NODEFILE`\n',
        'JOBID=$( echo $PBS_JOBID | awk -F \".\"  \'{print $1}\')\n',
        "echo \'JOB-ID = \'  $JOBID >> JOB-${JOBID}\n",
        "echo This job has allocated $NPROC procs >> JOB-${JOBID}\n",
        "TW=$( qstat -f \"$JOBID\" | grep -e \'Resource_List.walltime\' | awk -F \"=\" \'{print $(NF)}\' )\n",
        "echo \'requested walltime = \'  $TW  >> JOB-${JOBID}\n",
        "Q=$( qstat -f \"$JOBID\" | grep -e \'queue\' | awk \'{print $3}\' )\n",
        "echo \'requested queue = \'  $Q >> JOB-${JOBID}\n",
        "TC=$( qstat -f \"$JOBID\" | grep -e \'etime\' | awk -F \"=\" \'{print $(NF)}\' )\n",
        "TC_s=$( date -d \"$TC\" +%s )\n",
        "echo \'time submit = \'  $TC $TC_s >> JOB-${JOBID}\n",
        "TS=$( qstat -f \"$JOBID\" | grep -e \'start_time\' | awk -F \"=\" \'{print $(NF)}\' )\n",
        "TS_s=$( date -d \"$TS\" +%s )\n",
        "echo \'time start = \'  $TS  $TS_s >> JOB-${JOBID}\n",
        "TimeDu=`expr $TS_s - $TC_s`\n",
        "echo \'Waiting time(s) = \'  $TimeDu  >> JOB-${JOBID}\n",
        "\n",
        "echo This job has allocated $NPROC proc > log\n",
        "\n",
        "module load compiler/intel/2021.3.0\n",
        "module load mpi/intelmpi/2021.3.0\n",
        "\n",
        ]
    if type_hpc=="sbatch":
        jobscript_file_in=[
        "#!/bin/bash\n",
        "#SBATCH --job-name=xty\n",
        "#SBATCH -D ./\n",
        "#SBATCH --nodes=%d\n"%node_num,
        "#SBATCH --ntasks-per-node=%d\n"%ppn_num,
        "#SBATCH -o output.%j\n",
        "##SBATCH -e error.%j\n",
        "#SBATCH --time=%s\n"%wall_time,
        "#SBATCH --partition=dm_pub_cpu\n",
        "\n",
        "##SBATCH --gres=gpu:4 #if use gpu, uncomment this\n",
        "#export I_MPI_PMI_LIBRARY=/opt/gridview/slurm/lib/libpmi.so\n",
        "ulimit -s unlimited\n",
        "ulimit -l unlimited\n",
        "\n",
        "#setup intel oneapi environment \n",
        "source /dm_data/apps/intel/oneapi/setvars.sh\n",
        "#source /etc/profile\n",
        "module load compiler/latest\n",
        "module load mpi/latest\n",
        "module load mkl/latest\n",
        ]
    return jobscript_file_in,type_hpc,ppn_tot

jobscript_file,type_hpc_out,ppn_tot_out=JOB_func(type_flat,node_num)

#jobscript_file.append("mpirun -np 64 pw.x -npool 2 -ndiag 64 < in_%s_%s  >& out_%s_%s"%(mode,molecule_i,mode,molecule_i))

def psp_dir(element_i):                                 #your psp dir should be add here
    psp_format_list=["X.SG15.LDA.UPF","X.SG15.PBE.UPF","X_frl_gga.upf","X_srl_gga.upf","ONCV.PWM.X.UPF","ONCV.PWM.X.IN"]
    psp_head_dir="%s/bin/psp/"%root_dir
    psp_head_zf_dir="/hpc/data/home/spst/zhengfan/open/psp/"
    psp_dir=["NCPP-SG15-LDA","NCPP-SG15-PBE","NC_psp","NC_psp","ONCV-PWM-PBE/%s"%(element_i),"ONCV-PWM-PBE/%s"%(element_i)]
    psp_abs_dir=psp_head_dir+psp_dir[psp_format_list.index(sp_format)]+"/"
    psp_abs_zf_dir=psp_head_zf_dir+psp_dir[psp_format_list.index(sp_format)]+"/"
    return [psp_abs_dir,psp_abs_zf_dir]

def spin_form(element_spin):
    return ''.join([i for i in element_spin if not i.isdigit()])

def psp_form(element_i):
    mixed_ele_spe=[]
    element_i_s=[x for x in element_i.split(split_sybol_virtual) if len(x)>0]
    for jj in element_i_s:
        if (element_i_s.index(jj) % 2) == 0:
            mixed_ele_spe.append(jj)
    if sp_format.find("rl_gga.upf")==-1:
        if split_sybol_virtual not in element_i:
            psp_out=sp_format.replace("X",spin_form(element_i))
        elif split_sybol_virtual in element_i:
            psp_out=sp_format.replace("X",(spin_form(mixed_ele_spe[0])+spin_form(mixed_ele_spe[1])))
    else:
        if split_sybol_virtual not in element_i:
            psp_out=sp_format.replace("X",(chr(ord(element_i[0])+32)+spin_form(element_i[1:])))
        elif split_sybol_virtual in element_i:
            psp_out=sp_format.replace("X",(spin_form(mixed_ele_spe[0])+spin_form(mixed_ele_spe[1])))
    return psp_out

def rl_aw(element_i):
    element=["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Uun","Uuu","Uub"]   #end in 112
    atomic_weight=[1.01,4.00,6.94,9.01,10.81,12.01,14.01,16.00,19.00,20.17,22.99,24.31,26.98,28.09,30.97,32.06,35.45,39.94,39.10,40.08,44.96,47.9,50.94,52.00,54.94,55.84,58.93,58.69,63.54,65.38,69.72,72.5,74.92,78.9,79.90,83.8,85.47,87.62,88.91,91.22,92.91,95.94,99,101.07,102.91,106.42,107.87,112.41,114.82,118.6,121.7,127.6,126.91,131.3,132.91,137.33,138.91,140.12,140.91,144.2,147,150.4,151.96,157.25,158.93,162.5,164.93,167.2,168.93,173.0,174.96,178.4,180.95,183.8,186.21,190.2,192.2,195.08,196.97,200.5,204.3,207.2,208.98,209,201,222,223,226.03,227.03,232.04,231.04,238.03,237.05,244,243,247,247,251,254,257,258,259,260,261,262,263,262,265,266,269,272,277]
    if split_sybol_virtual not in element_i:
        return atomic_weight[element.index(''.join([i for i in element_i if not i.isdigit()]))]
    #create new element:
    if split_sybol_virtual in element_i:
        print("!!!  Virtual Crystal Approximation Detected  !!!")
        mixed_wt=0
        mixed_ele_spe=[]
        mixed_ele_wt=[]
        element_i_s=[x for x in element_i.split(split_sybol_virtual) if len(x)>0]
        for jj in element_i_s:
            if (element_i_s.index(jj) % 2) == 0:
                mixed_ele_spe.append(jj)
            elif (element_i_s.index(jj) % 2) == 1:
                mixed_ele_wt.append(jj)
        for ele_i in range(len(mixed_ele_spe)):
            mixed_wt+=atomic_weight[element.index(mixed_ele_spe[ele_i])]*float(mixed_ele_wt[ele_i])
     #generate new psp files:
        if os.path.isfile(sp_format.replace("X",(mixed_ele_spe[0]+mixed_ele_spe[1])))==0:
            #print("creating %s..."%sp_format.replace("X",element_i.replace(".",split_sybol_virtual)))
            print("creating %s..."%sp_format.replace("X",(mixed_ele_spe[0]+mixed_ele_spe[1])))
            psp_dir1=psp_dir(mixed_ele_spe[0])[0]
            psp_dir2=psp_dir(mixed_ele_spe[0])[1]
            #print(psp_dir1,psp_dir2)
            if (os.path.isfile(psp_form(mixed_ele_spe[0])))&(os.path.isfile(psp_form(mixed_ele_spe[1]))):
                print("PSP file founded!")
            elif os.path.exists(psp_dir1):
                for ii in range(len(mixed_ele_spe)):
                    print("copy from root %s"%psp_form(mixed_ele_spe[ii]))
                    os.system("cp %s/%s ." %(psp_dir(mixed_ele_spe[ii])[0],psp_form(mixed_ele_spe[ii])))
            elif os.path.exists(psp_dir2):
                for ii in range(len(mixed_ele_spe)):
                    print("copy from zhengfan/open %s"%psp_form(mixed_ele_spe[ii]))
                    os.system("cp %s/%s ." %(psp_dir(mixed_ele_spe[ii])[1],psp_form(mixed_ele_spe[ii])))
            f_tem_psp=open("tem_psp","w")
            f_tem_psp.writelines(psp_form(mixed_ele_spe[0])+"\n")
            f_tem_psp.writelines(psp_form(mixed_ele_spe[1])+"\n")
            f_tem_psp.writelines(mixed_ele_wt[0]+"\n")
            f_tem_psp.close()
            print("mixing %s %s ..."%(psp_form(mixed_ele_spe[0]),psp_form(mixed_ele_spe[1])))
            jjj=os.popen("%s/virtual_v2.x < tem_psp"%code_dir).readlines()
            #os.system("mv NewPseudo.UPF %s"%(sp_format.replace("X",element_i.replace(".",split_sybol_virtual))))
            os.system("mv NewPseudo.UPF %s"%(sp_format.replace("X",(mixed_ele_spe[0]+mixed_ele_spe[1]))))
        elif os.path.isfile(sp_format.replace("X",(mixed_ele_spe[0]+mixed_ele_spe[1])))==1:
            #print("%s detected!"%sp_format.replace("X",element_i.replace(".",split_sybol_virtual)))
            print("%s detected!"%sp_format.replace("X",(mixed_ele_spe[0]+mixed_ele_spe[1])))
        return float("%.2f"%mixed_wt) 
def read_vasp_single_file( filename ):
    with open(filename,'r') as f:
        raw = f.readlines()
    coorf = []; name = []; fix = []; lat = np.zeros( (3,3) )
    scale_factor = float(raw[1].split()[0])
    for order,i in enumerate(raw[2:5]):
        tmp_ = [float(j.strip().strip('\n')) for j in i.split()]
        lat[order,:] = np.array( tmp_ )
    name_set = raw[5].split()
#    for names_i in range(len(name_set)):
#        name_set[names_i]=name_set[names_i].replace(".","")
    name_count = [int(j) for j in raw[6].split()]
    name_count_spec = len(name_set)
    natom = sum( name_count )
    for iname in range(name_count_spec):
        for j in range(name_count[iname]):
            name.append( name_set[iname])
    for i in raw[8:natom+8]:
        tmp_ = [j.strip().strip('\n') for j in i.split()]
        tmp_2 = list(map(float, tmp_[0:3]))
        coorf.append( tmp_2 )
        coord = np.array(coorf)
    return np.array(name), lat, np.array(coord),natom,name_set


def bands_read(file_bands):
    bands_in_scf=[]
    readed=0
    f=open(file_bands,"r").readlines()
    for i in range(len(f)):
        if "occupation numbers" in f[i]:
            if readed==0:
                #print(i)
                for j in range(i+1,len(f)):
                    bands_line=f[j].split()
                    if len(bands_line)==0:
                        readed=1
                        break
                    elif len(bands_line)>0:
                        for k in bands_line:
                            if float(k)!=0:
                                bands_in_scf.append(k)
    bands_in_infile=int(len(bands_in_scf)*1.2)+1
    return bands_in_infile
#def print_func(name2,lat2,coord2,natom2):
#    print the way input file aquires
#    print("CELL_PARAMETERS {alat}",end='')
#    for i_cell_par in range(0,3):
#        print('')
#        print("   ",end='')
#        for j_cell_par in range(0,3):
#            print("%.10f"%lat2[i_cell_par][j_cell_par],end='')
#            print("      ",end='')
#    print('')
#    print("ATOMIC_POSITIONS (crystal)")
#    for i in range(natom2):
#        print("%s      %.9f     %.9f      %.9f "%(name2[i],coord2[i][0],coord2[i][1],coord2[i][2]),end='')
#        if(coord2[i][2]<upper_layer and coord2[i][2]>down_layer):
#            print("      0    0    0 ")
#        else:
#            print("      1    1    1 ")

def write_func(name2,lat2,coord2,natom2):
#    print the way input file aquires
    writethings=[]
    writethings.append("CELL_PARAMETERS {alat}\n")
    for i_cell_par in range(0,3):
        str="   "
        for j_cell_par in range(0,3):
            str+="%.10f"%lat2[i_cell_par][j_cell_par]
            str+="      "
        writethings.append(str+'\n')
        str=""
    writethings.append("ATOMIC_POSITIONS (crystal)\n")
    for i in range(natom2):
        if split_sybol_virtual in name2[i]:
            mixed_ele_spe=[]
            element_i_s=[x for x in name2[i].split(split_sybol_virtual) if len(x)>0]
            for jj in element_i_s:
                if (element_i_s.index(jj) % 2) == 0:
                    mixed_ele_spe.append(jj)
            str1="" 
            str1="%s      %.9f     %.9f      %.9f "%((mixed_ele_spe[0]+mixed_ele_spe[1]),coord2[i][0],coord2[i][1],coord2[i][2])
        else:
            str1="" 
            #str1="%s      %.9f     %.9f      %.9f "%(name2[i].replace(".",split_sybol_virtual),coord2[i][0],coord2[i][1],coord2[i][2])
            str1="%s      %.9f     %.9f      %.9f "%(name2[i],coord2[i][0],coord2[i][1],coord2[i][2])
        if ((mode=="surf")|(mode=="relax"))&(fixed_atom_mode==1):
            if(coord2[i][2]<upper_layer and coord2[i][2]>down_layer) or i in [x-1 for x in fixed_atom_index]:
                str1+="      0    0    0 "
            else:
                str1+="      1    1    1 "
        writethings.append(str1+'\n')
#   print(writethings)
    return writethings


def file_create_func(ina,name1,lat1,coord1,natom1,name_set1,jobscript_file):
    error=0
    raws_1=[]
    raws2=[]
    mark=0
    mark_kpoints=0
    molecule_i=''
    if ina != 'SIG':
        file_name=molecule+cnct_syb+str(ina)
        fnm=export_input_file+cnct_syb+str(ina)
        molecule_i=molecule+cnct_syb+str(ina)
    if ina == 'SIG':
        file_name=molecule
        fnm=export_input_file
        molecule_i=molecule
    isExists = os.path.exists(file_name)
    if isExists:
        os.chdir("%s/%s" %(dir,file_name)) 
        if os.path.isfile("delete_me_rm_file")==1:
            print("you must have done the scf or other calculation")
            os.chdir("/%s"%dir)
        else:
            os.chdir("/%s"%dir)
            os.system("rm -rf %s" %file_name)
            time.sleep(2)
            os.system("mkdir %s"%file_name)
            os.mknod("delete_me_rm_file")
            os.system("mv delete_me_rm_file %s"%file_name)          
    else: 
        os.system("mkdir %s"%file_name)
        os.mknod("delete_me_rm_file")
        os.system("mv delete_me_rm_file %s"%file_name)
    if os.path.isfile(fnm) == True:
        os.system("rm "+fnm)       
        time.sleep(1)
    os.mknod(fnm)                                #input_file_modify
    f1=open(input,"r+")
    if (mode!="pdos")&(mode!="BaderCharge"):
        f2=open(mode_name,"r+")
        raws2=f2.readlines()
#modify the input files
    if (mode=="pdos")|(mode=="BaderCharge"):
        if (os.path.isfile("%s/out_scf_%s"%(molecule_i,molecule_i))==0)&(os.path.isfile("%s/out_relax_%s"%(molecule_i,molecule_i))==0):
            error=1
            print(f"!!!ERROR:No scf has done before!plz do a scf before {mode} calculation!")
            return error
        else:
            f_make_pdos=open(fnm,"w")
            if mode=="pdos":
                input_postprocess=[
                "&PROJWFC\n",
                f"  prefix = \'{prefix}\',\n",
                "  outdir = \'./\',\n",
                "  ngauss = 0,\n",
                "  degauss = 0.01,\n",
                "/\n"
                ]
            elif mode=="BaderCharge":
                input_postprocess=[
                "&INPUTPP\n",
                f"  prefix = \'{prefix}\',\n",
                "  outdir = \'./\',\n",
                f"  filplot = \'Bader_{molecule}\',\n",
                "  plot_num = 0,\n",
                "/\n"
                "&PLOT\n",
                "  nfile = 1,\n",
                "  iflag = 3,\n",
                "  output_format = 6,\n",
                f"  fileout = \'Bader_{molecule}.cube\',\n",
                "/\n"
                ]

            for i in input_postprocess:
                f_make_pdos.writelines(i) 
            f_make_pdos.close()
            os.system("mv %s %s"%(fnm,file_name))
    elif (mode!="pdos")&(mode!="BaderCharge"):
        ##spin modify code
        if os.path.isfile(spin_file):
            for i,lines in enumerate(raws2):
                if "nspin" in lines:
                    if "2" in lines:
                        pass
                    if "4" in lines:
                        raise ValueError("This autoscript is only for spin=2, plz delete the SPIN and set the spin manually!")
                    if "1" in lines:
                        raws2.remove(raws2[i])
                        spin_line_reset=1

            for i,lines in enumerate(raws2[::-1]): # clear the former starting_set  python.remove() has some problem with a for loop :https://blog.csdn.net/m0_46521785/article/details/111303860
                if "nspin" in lines:
                    raws2.remove(lines)
                elif "starting_magnetization" in lines:
                    raws2.remove(lines)
            spin_input_lines=[]
            spin_input_lines.append("    nspin = 2,\n")
            spin_file_line=open(spin_file).readlines()
            for i,lines in enumerate(spin_file_line):
                if "#" in lines:
                    pass
                else:
                    spin_ele=[x for x in lines.strip("\n").split() if len(x)>0]
                    if spin_ele[0] in name_set1:
                        spin_index=name_set1.index(spin_ele[0])+1
                        spin_input_lines.append(f"    starting_magnetization({spin_index})={spin_ele[1]},\n")
                    #else:
                    #    print(f"{spin_ele[0]} not in {name_set1}")

        elif not os.path.isfile(spin_file):
            for i,lines in enumerate(raws2[::-1]): # clear the former starting_set  python.remove() has some problem with a for loop :https://blog.csdn.net/m0_46521785/article/details/111303860
                if "nspin" in lines:
                    raws2.remove(lines)
                elif "starting_magnetization" in lines:
                    raws2.remove(lines)

        ##dft+u modify code
        if os.path.isfile(dftu_file):
            for i,lines in enumerate(raws2):
                if "lda_plus_u_kind" in lines:
                    if "0" in lines:
                        pass
                    else:
                        raise ValueError("This autoscript is only for lda_plu_u=0, plz delete the DFT-U and set the dft+u manually!")

            for lines in raws2[::-1]: # clear the former lda_plus_u_set
                if lines.find("Hubbard_U")!=-1:
                    raws2.remove(lines)
                elif lines.find("lda_plus_u")!=-1:
                    raws2.remove(lines)
            dftu_input_lines=[]
            dftu_input_lines.append("    lda_plus_u = .true.\n")
            dftu_input_lines.append("    lda_plus_u_kind = 0\n")
            dftu_file_line=open(dftu_file).readlines()
            for i,lines in enumerate(dftu_file_line):
                if "#" in lines:
                    pass
                else:
                    dftu_ele=[x for x in lines.strip("\n").split() if len(x)>0]
                    if dftu_ele[0] in name_set1:
                        dftu_index=name_set1.index(dftu_ele[0])+1
                        dftu_input_lines.append(f"    Hubbard_U({dftu_index})={dftu_ele[1]},\n")
                    #else:
                        #print(f"{dftu_ele[0]} not in {name_set1}")
        if not os.path.isfile(dftu_file):
            for lines in raws2[::-1]: # clear the former lda_plus_u_set
                if lines.find("Hubbard_U")!=-1:
                    raws2.remove(lines)
                elif lines.find("lda_plus_u")!=-1:
                    raws2.remove(lines)

        for i in range(len(raws2)):
            if raws2[i].find('ATOMIC_SPECIES')!= -1:
                mark=i
            if raws2[i].find('K_POINTS')!= -1:
                mark_kpoints=i
        if mark == 0:
            print("file not found")
        raws_1=raws2[:mark]
        ##found the insert point 
        input_index_spin_ldau=0
        for i,lines in enumerate(raws_1):
            if "ecutwfc" in lines:
                input_index_spin_ldau=i+1
        if input_index_spin_ldau==0:
            raise ValueError("No ecutwfc found in input, plz specify the ecutwfc")
        #insert the spin and ldau into input file
        if os.path.isfile(spin_file):
            for lines in spin_input_lines[::-1]:
                raws_1.insert(input_index_spin_ldau,lines)
                #print(lines)
        if os.path.isfile(dftu_file):
            for lines in dftu_input_lines[::-1]:
                raws_1.insert(input_index_spin_ldau,lines)
                #print(lines)
        ntyp_index=0
        find_nat=0
        for i in range(len(raws_1)):
            if raws_1[i].find("nat=")!=-1:
                raws_1[i]="    nat=  %d,\n"%natom1
                find_nat=1
            if raws_1[i].find("ntyp=")!=-1:
                raws_1[i]="    ntyp= %d,\n"%len(name_set1)
                ntyp_index=i
                #print(ntyp_index)
        if find_nat==0:
            print("!!!ERROR,not nat= found!")
            error=1
            return error
        if mode=="bands":
            if (os.path.isfile("%s/out_scf_%s"%(molecule_i,molecule_i))==0)&(os.path.isfile("%s/out_relax_%s"%(molecule_i,molecule_i))==0): 
                error=1
                print("!!!ERROR:No scf has done before!plz do a scf before bands calculation!")
                return error
            find_nbnd=0
            find_nbnd_index=0
            for raws_input in raws_1:
                #print(raws_input)
                if raws_input.find("nbnd")!=-1:
                    find_nbnd=1
                    find_nbnd_index=raws_1.index(raws_input)
                    #print("!!!!nbnd found")
            if os.path.isfile("%s/out_scf_%s"%(molecule_i,molecule_i))==1:
                bands_num=bands_read("%s/out_scf_%s"%(molecule_i,molecule_i))
            elif os.path.isfile("%s/out_scf_%s"%(molecule_i,molecule_i))==0:
                bands_num=bands_read("%s/out_relax_%s"%(molecule_i,molecule_i))
            if bands_num==0:
                error=1
                print("Something is wrong with bands in you scf output file!")
                return error
            if find_nbnd==1:
                raws_1[find_nbnd_index]="    nbnd= %d,\n"%bands_num
            elif find_nbnd==0:
                raws_1.insert(ntyp_index,"    nbnd= %d,\n"%bands_num)
        raws_1.append("ATOMIC_SPECIES\n")
        SP=[]
        for i in range(len(name_set1)):
            SP.append(psp_form(name_set1[i]))
            if split_sybol_virtual in name_set1[i]:
                mixed_ele_spe=[]
                element_i_s=[x for x in name_set1[i].split(split_sybol_virtual) if len(x)>0]
                for jj in element_i_s:
                    if (element_i_s.index(jj) % 2) == 0:
                        mixed_ele_spe.append(jj)
                raws_1.append("%3s  %6.2f   %s\n"%((mixed_ele_spe[0]+mixed_ele_spe[1]),rl_aw(name_set1[i]),SP[i]))
            else:
                #raws_1.append("%3s  %6.2f   %s\n"%(name_set1[i].replace(".",split_sybol_virtual),rl_aw(name_set1[i]),SP[i]))
                raws_1.append("%3s  %6.2f   %s\n"%(name_set1[i],rl_aw(name_set1[i]),SP[i]))
    
        raws_1.append(raws2[mark_kpoints])
    
        kpoint_type=raws2[mark_kpoints+1].split(" ")
        kpoint_type_len=[]
        for i in kpoint_type:
            if (len(i)>0)&(i!="\n"):
                kpoint_type_len.append(i)
        #print("************************************",kpoint_type_len)
        if len(kpoint_type_len)>1:       #more than one number in k point,aka a normal kpoint sample
            raws_1.append(raws2[mark_kpoints+1])
        elif len(kpoint_type_len)==1: #only one number in first line in k point, aka k-path sample
            for n in range(mark_kpoints+1,mark_kpoints+1+int(kpoint_type_len[0])+1):
                raws_1.append(raws2[n])
        for i in range(len(raws_1)):
            f3=open(fnm,"a")
            f3.write(raws_1[i])
            f3.close()
        f4=open(fnm,"a+")
        f4.writelines(write_func(name1,lat1,coord1,natom1))
        os.system("mv %s %s"%(fnm,file_name))
    
    
        if solvation_model==1:
        #Environ file cp
            if os.path.isfile("./environ.in")==1:
                os.system("cp environ.in %s"%file_name)
                print("environ file found!")
            else:
                error=1
                print("!!!ERROR:environ.in file needed!")
                return error
        for i in range(len(SP)):
            if os.path.isfile(SP[i])==1:
                print("%s founded!"%SP[i])
                os.system("cp %s %s" %(SP[i],file_name))
            elif os.path.exists("/hpc/data/home/spst/xiety/bin/psp"):
                print("copy from root %s"%SP[i])
                os.system("cp %s/%s %s" %(psp_dir(name_set1[i])[0],SP[i],file_name))
            else:
                print("copy from zhengfan/open %s"%SP[i])
                os.system("cp %s/%s %s" %(psp_dir(name_set1[i])[1],SP[i],file_name))

#modify job and sub job
    os.chdir("%s/%s" %(dir,file_name)) 
    if os.path.isfile(JOB)==1:                                      #job file modify
        os.system("rm %s"%JOB)
    os.mknod(JOB)
    fj=open(JOB,"a+")
    jobscript_file_1=[]
    for i in range(len(jobscript_file)):
        j_rename=""
        #print(jobscript_file[i],type(jobscript_file[i]),i)
        if type_hpc_out=="pbs":
            if jobscript_file[i].find('#PBS  -N')!=-1:
                job_name_split=vaspfile.split("_")
                for j_names in job_name_split:
                    j_rename+=j_names[:2].zfill(2)
                jobscript_file[i]='#PBS  -N   %s%s\n'%(j_rename,str(ina))
            jobscript_file_1.append(jobscript_file[i])
        if type_hpc_out=="sbatch":
            if jobscript_file[i].find('#SBATCH --job-name')!=-1:
                job_name_split=vaspfile.split("_")
                for j_names in job_name_split:
                    j_rename+=j_names[:2].zfill(2)
                jobscript_file[i]='#SBATCH --job-name=%s%s\n'%(j_rename,str(ina))
            jobscript_file_1.append(jobscript_file[i])
    if (type_hpc_out=="pbs") & (mode!="pdos") & (mode!="BaderCharge"):
        if solvation_model==0:
            jobscript_file_1.append("mpirun --bind-to core -np $NPROC -hostfile $PBS_NODEFILE %s/pw-6.8.x -npool 4 -ndiag 4 < in_%s_%s  >& out_%s_%s"%(qe_dir,mode,molecule_i,mode,molecule_i)) 
        elif solvation_model==1:
            jobscript_file_1.append("mpirun --bind-to core -np $NPROC -hostfile $PBS_NODEFILE %s/pw-7.2-environ.x -npool 4 -ndiag 4 --environ < in_%s_%s  >& out_%s_%s"%(qe_dir,mode,molecule_i,mode,molecule_i))
    elif (type_hpc_out=="sbatch") & (mode!="pdos") & (mode!="BaderCharge"):
        if solvation_model==0:
            jobscript_file_1.append("mpirun --bind-to core -np %s %s/pw-6.8.x -npool 4 -ndiag 4 < in_%s_%s  >& out_%s_%s"%(ppn_tot_out,qe_dir,mode,molecule_i,mode,molecule_i))
        elif solvation_model==1:
            jobscript_file_1.append("mpirun --bind-to core -np %s -hostfile $PBS_NODEFILE %s/pw-7.2-environ.x -npool 4 -ndiag 4 --environ < in_%s_%s  >& out_%s_%s"%(ppn_tot_out,qe_dir,mode,molecule_i,mode,molecule_i))
    elif (mode=="pdos"):
        jobscript_file_1.append("mpirun --bind-to core -np %s %s/projwfc.x -npool 4 -ndiag 4 < in_%s_%s  >& out_%s_%s"%(ppn_tot_out,qe_dir,mode,molecule_i,mode,molecule_i))
    elif (mode=="BaderCharge"):
        jobscript_file_1.append("mpirun --bind-to core -np %s %s/pp.x -npool 4 -ndiag 4 < in_%s_%s  >& out_%s_%s"%(ppn_tot_out,qe_dir,mode,molecule_i,mode,molecule_i))


    fj.writelines(jobscript_file_1)
    jobscript_file_1=[]
    fj.close()
    if bcon_mode==1:
        print("bcon.sh mode on!")
        out_file_test=''
        out_file_test='out_'+mode+'_'+molecule_i
        if os.path.isfile(out_file_test)==1:
            print("replace the outfile into infile")
            #print("bcon.sh out_%s_%s in_%s_%s"%(mode,molecule_i,mode,molecule_i))
            os.system("bcon.sh out_%s_%s in_%s_%s"%(mode,molecule_i,mode,molecule_i))

    if (sub_script==1)&(error==0):
        if type_hpc_out=="sbatch":
            os.system("sbatch %s"%JOB)
        if type_hpc_out=="pbs":
            os.system("qsub %s" %JOB)                             #change it with your HCP
    time.sleep(1)
    os.chdir("/%s"%dir)
    return error

#print("batchmode:%s"%batch_mode)




if (batch_mode==1) & (error==0):
    #print("batchmode 1")
    for i in range(file_min,file_max+1):

        input=molecule+cnct_syb+str(i)+input2
        print(input+' searching...')
        name1=[]
        lat1=[]
        coord1=[]
        natom=0
        name_set1=[]
        if os.path.isfile(input) == True:
            name1,lat1,coord1,natom1,name_set1=read_vasp_single_file(input)
            error=file_create_func(i,name1,lat1,coord1,natom1,name_set1,jobscript_file)  
            print("%s is detected!"%input)
        else:
            error=1
            print("%s is not exsist"%input)

elif (batch_mode == 0) & (error==0):
    #print("batchmode 0")
    input=molecule+input2
    print(input+' searching...')
    name2=[]
    lat2=[]
    coord2=[]
    natom2=0
    name_set2=[]
    if os.path.isfile(input) == True:
        name2,lat2,coord2,natom2,name_set2=read_vasp_single_file(input)
        error=file_create_func("SIG",name2,lat2,coord2,natom2,name_set2,jobscript_file)
        print("%s is detected!"%input)
    else:
        error=1
        print("%s is not exsist"%input)
#print("error is ",error)
if error==0:
    if type_hpc_out=="pbs":
        os.system("qstat")                                           #change it with your HCP
    elif type_hpc_out=="sbatch":
        os.system("squeue")
    print("Congradulations,your time was saved by automatic script!")
if error==1:
    print("An error occur!")
